# 导航和子图管理系统

## 系统概述

导航系统是项目的核心特性之一，实现了无限层级的子图嵌套功能。用户可以双击矩形节点进入子图，在子图中继续创建和编辑内容，形成层级化的图形结构。

## 1. Navigation 类 (navigation.js)

### 核心属性

```javascript
class Navigation {
  constructor(graph) {
    this.graph = graph;
    this.graphStack = [];           // 图层级栈
    this.currentGraphData = {       // 当前显示的图数据
      id: 'root',
      nodes: [],
      edges: [],
      parentNode: null,
      label: 'Root'
    };
    this.backButton = new BackButton(this);
    this.createNavigationBar();
    this.bindEvents();
  }
}
```

### 数据结构

#### graphStack (图层级栈)
- **类型**: Array
- **用途**: 存储图的层级关系
- **结构**: 每个元素都是完整的图数据对象
- **操作**: 进入子图时push，返回时pop

#### currentGraphData (当前图数据)
```javascript
{
  id: 'subgraph-nodeId',    // 子图唯一标识
  nodes: [],                // 当前图的节点数组
  edges: [],                // 当前图的边数组
  parentNode: 'nodeId',     // 父节点ID
  label: 'NodeLabel'        // 显示标签
}
```

### 核心方法

#### enterSubgraph(node) - 进入子图
```javascript
enterSubgraph(node) {
  const model = node.getModel();
  
  // 只处理普通矩形节点
  if (model.type === 'text-only' || model.type === 'image-node') return;
  
  // 保存当前图形状态
  this.updateCurrentGraphData();
  
  // 将当前状态推入栈
  this.graphStack.push({...this.currentGraphData});
  
  // 初始化子图（如果不存在）
  if (!model.subGraph) {
    model.subGraph = {
      id: `subgraph-${model.id}`,
      nodes: [],
      edges: [],
      parentNode: model.id
    };
  }
  
  // 切换到子图
  this.currentGraphData = model.subGraph;
  this.graph.data(this.currentGraphData);
  this.graph.render();
  
  // 更新导航
  this.updatePath();
  this.backButton.update();
}
```

#### goBack() - 返回上级图
```javascript
goBack() {
  if (this.graphStack.length > 0) {
    // 保存当前子图状态
    this.updateCurrentGraphData();
    
    // 更新父节点的子图数据
    const parentGraph = this.graphStack[this.graphStack.length - 1];
    const parentNode = parentGraph.nodes.find(
      node => node.id === this.currentGraphData.parentNode
    );
    if (parentNode) {
      parentNode.subGraph = {...this.currentGraphData};
    }
    
    // 恢复父图
    this.currentGraphData = this.graphStack.pop();
    this.graph.data(this.currentGraphData);
    this.graph.render();
    
    // 更新导航
    this.updatePath();
    this.backButton.update();
  }
}
```

#### navigateToLevel(level) - 直接跳转层级
```javascript
navigateToLevel(level) {
  if (level < 0 || level > this.graphStack.length) return;
  
  // 保存当前状态
  this.updateCurrentGraphData();
  
  if (level === 0) {
    // 导航到根节点
    while (this.graphStack.length > 0) {
      const currentState = this.graphStack.pop();
      const parentNode = currentState.nodes.find(
        node => node.id === this.currentGraphData.parentNode
      );
      if (parentNode) {
        parentNode.subGraph = {...this.currentGraphData};
      }
      this.currentGraphData = currentState;
    }
  } else {
    // 导航到指定层级
    while (this.graphStack.length > level) {
      // 类似逻辑...
    }
  }
  
  // 更新图形和UI
  this.graph.data(this.currentGraphData);
  this.graph.render();
  this.updatePath();
  this.backButton.update();
}
```

#### updateCurrentGraphData() - 保存当前状态
```javascript
updateCurrentGraphData() {
  const savedState = this.graph.save();
  this.currentGraphData.nodes = savedState.nodes.map(node => ({...node}));
  this.currentGraphData.edges = savedState.edges.map(edge => ({...edge}));
}
```

### 导航路径更新

#### updatePath() - 更新导航路径
```javascript
updatePath() {
  const navBar = document.getElementById('navigation-bar');
  const pathElements = [];
  
  // 添加根节点及点击处理
  pathElements.push(`<span class="nav-node" onclick="window._navigateToLevel(0)">Root</span>`);
  
  // 添加中间节点及点击处理
  this.graphStack.forEach((graph, index) => {
    const node = graph.nodes.find(n => n.id === this.graphStack[index + 1]?.parentNode);
    if (node) {
      pathElements.push('<span class="nav-separator">/</span>');
      pathElements.push(
        `<span class="nav-node" onclick="window._navigateToLevel(${index + 1})">${node.label || 'Unnamed'}</span>`
      );
    }
  });
  
  // 添加当前节点（如果在子图中）
  if (this.currentGraphData.parentNode) {
    const parentGraph = this.graphStack[this.graphStack.length - 1];
    const parentNode = parentGraph.nodes.find(n => n.id === this.currentGraphData.parentNode);
    if (parentNode) {
      pathElements.push('<span class="nav-separator">/</span>');
      pathElements.push(`<span class="nav-current">${parentNode.label || 'Unnamed'}</span>`);
    }
  }
  
  navBar.querySelector('.nav-path').innerHTML = pathElements.join('');
}
```

## 2. BackButton 类 (backButton.js)

### 基本功能
- **位置**: 右上角固定按钮
- **显示逻辑**: 只在子图中显示，根图中隐藏
- **文本**: 显示父级节点名称

### 核心方法

#### createBackButton() - 创建按钮
```javascript
createBackButton() {
  const button = document.createElement('button');
  button.id = 'backButton';
  button.innerText = '← Back to Parent';
  button.style.position = 'fixed';
  button.style.top = '10px';
  button.style.right = '10px';
  button.style.display = 'none';  // 初始隐藏
  // ... 其他样式设置
  return button;
}
```

#### update() - 更新按钮状态
```javascript
update() {
  if (this.navigation.graphStack.length > 0) {
    const parentGraph = this.navigation.graphStack[this.navigation.graphStack.length - 1];
    const parentNode = parentGraph.nodes.find(
      node => node.id === this.navigation.currentGraphData.parentNode
    );
    this.button.innerHTML = `← Back to ${parentNode ? parentNode.label || 'Unnamed' : 'Parent'}`;
    this.button.style.display = 'block';
  } else {
    this.button.style.display = 'none';
  }
}
```

## 3. 导航栏 UI

### HTML 结构
```javascript
createNavigationBar() {
  const navBar = document.createElement('div');
  navBar.id = 'navigation-bar';
  
  const pathSpan = document.createElement('span');
  pathSpan.className = 'nav-path';
  pathSpan.textContent = 'Root';
  
  navBar.appendChild(pathSpan);
  document.body.appendChild(navBar);
}
```

### CSS 样式特点
- **位置**: `position: fixed; bottom: 20px; left: 50%;`
- **居中**: `transform: translateX(-50%);`
- **响应式**: `min-width: 400px; max-width: 80%;`
- **交互**: 悬停效果和点击状态

### 路径显示格式
```
Root / Node1 / Node2 / 当前节点
```

- **Root**: 总是显示，可点击返回根图
- **中间节点**: 蓝色可点击，显示节点标签
- **当前节点**: 加粗显示，不可点击
- **分隔符**: 灰色 "/" 符号

## 4. 子图数据结构

### 节点中的子图属性
```javascript
// 矩形节点模型
{
  id: 'node-123',
  type: 'rectangle-node',
  label: 'My Node',
  subGraph: {                    // 子图数据
    id: 'subgraph-node-123',
    nodes: [                     // 子图中的节点
      { id: 'child-1', ... },
      { id: 'child-2', ... }
    ],
    edges: [                     // 子图中的边
      { source: 'child-1', target: 'child-2', ... }
    ],
    parentNode: 'node-123'       // 父节点引用
  }
}
```

### 子图初始化
- **时机**: 首次双击矩形节点时
- **结构**: 空的节点和边数组
- **关联**: parentNode 指向父节点ID

## 5. 事件绑定

### 双击进入子图
```javascript
bindEvents() {
  this.graph.on('node:dblclick', (ev) => {
    const node = ev.item;
    const model = node.getModel();
    
    // 跳过图片节点和文本节点
    if (model.type === 'image-node' || model.type === 'text-only') {
      return;
    }
    
    this.enterSubgraph(node);
  });

  // 暴露导航函数到全局作用域（用于导航路径点击）
  window._navigateToLevel = (level) => {
    this.navigateToLevel(level);
  };
}
```

## 6. 状态管理

### 图状态保存时机
1. **进入子图前**: 保存当前图状态到栈
2. **返回上级前**: 保存子图状态到父节点
3. **跳转层级前**: 保存当前状态
4. **文件保存时**: 获取完整层级数据

### 状态同步
- **实时同步**: 图的修改实时反映在 currentGraphData 中
- **层级同步**: 切换层级时同步所有相关数据
- **UI同步**: 导航路径和返回按钮状态实时更新

## 7. 使用场景

### 典型工作流程
1. 用户在根图创建矩形节点
2. 双击矩形节点进入子图
3. 在子图中创建更多内容
4. 通过导航栏或返回按钮切换层级
5. 保存时包含所有层级的完整数据

### 优势特点
- **无限嵌套**: 理论上支持无限层级
- **直观导航**: 清晰的路径显示和快速跳转
- **状态保持**: 各层级状态完整保存
- **用户友好**: 符合直觉的交互方式


