# 节点搜索功能详解

## 功能概述

节点搜索功能是项目的重要特性之一，提供了类似VSCode Ctrl+P的快速搜索体验。用户可以通过Ctrl+F快捷键打开搜索对话框，实时搜索任意层级的节点，并快速导航到目标位置。

## 1. 搜索系统架构

### 核心组件

```javascript
// 搜索模块结构
src/search/
├── index.js           // 模块导出
├── nodeSearch.js      // 主搜索类
└── searchEvents.js    // 搜索事件绑定
```

### 主要类和方法

#### NodeSearch 类
```javascript
class NodeSearch {
  constructor(graph, navigation) {
    this.graph = graph;                    // G6图形实例
    this.navigation = navigation;          // 导航系统实例
    this.isVisible = false;               // 对话框显示状态
    this.selectedIndex = 0;               // 当前选中结果索引
    this.searchResults = [];              // 搜索结果列表
    this.createSearchDialog();            // 创建搜索对话框
  }
}
```

## 2. 搜索对话框实现

### 对话框结构

```javascript
createSearchDialog() {
  // 创建搜索对话框背景容器
  this.dialog = document.createElement('div');
  this.dialog.id = 'node-search-dialog';
  this.dialog.className = 'search-dialog hidden';

  // 创建内容容器
  this.contentContainer = document.createElement('div');

  // 创建搜索输入框
  this.searchInput = document.createElement('input');
  this.searchInput.type = 'text';
  this.searchInput.className = 'search-input';
  this.searchInput.placeholder = 'Search nodes...';

  // 创建结果列表容器
  this.resultsList = document.createElement('div');
  this.resultsList.className = 'search-results';

  // 创建空状态提示
  this.emptyState = document.createElement('div');
  this.emptyState.className = 'search-empty-state';
  this.emptyState.textContent = 'No nodes found';
}
```

### 样式设计

```css
/* 搜索对话框样式 */
.search-dialog {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: flex-start;
  justify-content: center;
  padding-top: 15vh;
  z-index: 2000;
  backdrop-filter: blur(2px);
}

.search-input {
  border: none;
  outline: none;
  padding: 20px 24px;
  font-size: 18px;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  border-bottom: 1px solid #e8e8e8;
  background: #fafafa;
}

.search-result-item {
  padding: 16px 24px;
  cursor: pointer;
  border-bottom: 1px solid #f0f0f0;
  transition: background-color 0.15s ease;
}

.search-result-item.selected {
  background: #e6f7ff;
  border-left: 3px solid #1890ff;
}
```

## 3. 搜索逻辑实现

### 节点收集机制

```javascript
getAllNodes() {
  const allNodes = [];
  
  // 递归收集所有节点
  const collectNodes = (graphData, path = ['Root'], parentNodeId = null) => {
    if (!graphData || !graphData.nodes) return;
    
    graphData.nodes.forEach(node => {
      // 构建当前节点的完整路径
      const currentPath = [...path];
      
      // 收集所有类型的节点，但标记类型
      allNodes.push({
        node: node,
        path: currentPath,
        graphData: graphData,
        nodeType: node.type || 'rectangle-node',
        parentNodeId: parentNodeId
      });

      // 只有矩形节点可以有子图
      if ((!node.type || node.type === 'rectangle-node') && node.subGraph && node.subGraph.nodes) {
        const nodeLabel = node.label || 'Unnamed';
        // 子图中的节点路径应该包含当前节点
        collectNodes(node.subGraph, [...currentPath, nodeLabel], node.id);
      }
    });
  };

  // 从根图开始收集
  collectNodes(this.getRootGraphData());
  return allNodes;
}
```

### 实时搜索处理

```javascript
handleSearch(query) {
  console.log('🔍 [NodeSearch] 开始搜索:', query);
  
  // 在搜索前，确保导航数据是最新的
  this.navigation.updateCurrentGraphData();
  
  // 比较实际图形和导航数据的一致性
  const actualGraphNodes = this.graph.getNodes();
  const navigationNodes = this.navigation.currentGraphData.nodes || [];
  
  const allNodes = this.getAllNodes();
  
  if (query.trim() === '') {
    // 显示所有节点
    this.searchResults = allNodes;
  } else {
    // 过滤匹配的节点
    this.searchResults = allNodes.filter(nodeInfo => 
      nodeInfo.node.label && 
      nodeInfo.node.label.toLowerCase().includes(query.toLowerCase())
    );
  }

  this.selectedIndex = 0;
  this.renderResults();
}
```

## 4. 跨层级导航实现

### 精确路径导航

```javascript
navigateToPath(targetPath, targetNodeId) {
  console.log('🔍 [NodeSearch] 开始精确路径导航:', {
    targetPath,
    targetNodeId
  });

  // 先返回到根图
  this.navigation.navigateToLevel(0);
  
  // 如果目标就在根图，直接居中
  if (targetPath.length === 1) {
    setTimeout(() => {
      this.centerOnNode(targetNodeId);
    }, 50);
    return;
  }
  
  // 逐级导航到目标路径
  this.navigateStepByStep(targetPath, 1, targetNodeId);
}
```

### 逐步导航机制

```javascript
navigateStepByStep(targetPath, currentStep, targetNodeId) {
  if (currentStep >= targetPath.length) {
    // 已到达目标层级，居中显示节点
    console.log('🔍 [NodeSearch] 到达目标层级，居中节点');
    setTimeout(() => {
      this.centerOnNode(targetNodeId);
    }, 100);
    return;
  }
  
  const stepNodeName = targetPath[currentStep];
  
  // 在当前层级寻找对应的节点
  const currentNodes = this.graph.getNodes();
  const targetNode = currentNodes.find(node => {
    const model = node.getModel();
    return (model.label || 'Unnamed') === stepNodeName;
  });
  
  if (!targetNode) {
    console.error('🔍 [NodeSearch] 未找到路径节点:', stepNodeName);
    return;
  }
  
  // 检查节点类型，只有矩形节点可以进入子图
  const targetModel = targetNode.getModel();
  if (targetModel.type === 'image-node' || targetModel.type === 'text-only') {
    console.error('🔍 [NodeSearch] 节点类型不支持子图:', targetModel.type);
    return;
  }
  
  // 如果这是最后一步，目标节点就在这个子图中
  if (currentStep === targetPath.length - 1) {
    this.navigation.enterSubgraph(targetNode);
    setTimeout(() => {
      this.centerOnNode(targetNodeId);
    }, 150);
  } else {
    this.navigation.enterSubgraph(targetNode);
    setTimeout(() => {
      this.navigateStepByStep(targetPath, currentStep + 1, targetNodeId);
    }, 100);
  }
}
```

## 5. 节点居中实现

### 主要居中方法

```javascript
centerOnNode(nodeId) {
  const node = this.graph.findById(nodeId);
  if (!node) return;

  // 使用updateSelection工具函数来正确管理选择状态
  // 这样可以确保与现有的选择机制兼容
  updateSelection(this.graph, node);
  
  // 使用G6的focusItem方法进行居中，这比手动计算更可靠
  try {
    // 先重置缩放比例以确保节点能正确居中
    const currentZoom = this.graph.getZoom();
    
    // 如果缩放比例过小或过大，先调整到合适的比例
    if (currentZoom < 0.5 || currentZoom > 2) {
      this.graph.zoomTo(1.0);
    }
    
    // 使用focusItem方法居中显示节点
    this.graph.focusItem(node, true, {
      easing: 'easeCubic',
      duration: 200,
    });
    
  } catch (error) {
    console.error('🔍 [NodeSearch] focusItem 执行失败:', error);
    // 如果focusItem失败，回退到手动计算方式
    this.fallbackCenterNode(node);
  }
}
```

### 备用居中方法

```javascript
fallbackCenterNode(node) {
  const model = node.getModel();
  
  // 首先使用updateSelection确保选择状态正确
  updateSelection(this.graph, node);
  
  // 计算居中位置
  const width = this.graph.get('width');
  const height = this.graph.get('height');
  const centerX = width / 2;
  const centerY = height / 2;
  
  // 获取当前缩放级别
  const zoom = this.graph.getZoom();
  
  // 计算需要移动的距离
  const dx = centerX - model.x * zoom;
  const dy = centerY - model.y * zoom;
  
  // 移动画布使节点居中
  this.graph.translate(dx, dy);
}
```

## 6. 键盘交互实现

### 快捷键绑定

```javascript
// 在 searchEvents.js 中
export const bindSearchEvents = (graph, nodeSearch) => {
  // 监听 Ctrl+F 快捷键
  document.addEventListener('keydown', (e) => {
    // 如果正在输入文本，不处理快捷键
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
      return;
    }

    // 检查是否按下了 Ctrl+F
    if (e.ctrlKey && e.key === 'f') {
      e.preventDefault(); // 阻止浏览器默认的查找功能
      nodeSearch.show();
    }
  });
};
```

### 对话框内键盘导航

```javascript
bindDialogEvents() {
  // 键盘导航
  this.searchInput.addEventListener('keydown', (e) => {
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        this.selectNext();
        break;
      case 'ArrowUp':
        e.preventDefault();
        this.selectPrevious();
        break;
      case 'Enter':
        e.preventDefault();
        this.selectCurrentResult();
        break;
      case 'Escape':
        e.preventDefault();
        this.hide();
        break;
    }
  });
}
```

## 7. 数据同步机制

### 实时数据更新

```javascript
getRootGraphData() {
  // 获取完整的根图数据
  if (this.navigation.graphStack.length === 0) {
    // 如果在根图中，先更新当前数据以包含最新的节点，然后返回
    this.navigation.updateCurrentGraphData();
    return this.navigation.currentGraphData;
  }
  
  // 如果在子图中，需要构建完整的根图数据
  this.navigation.updateCurrentGraphData();
  
  // 从栈底开始重建完整的图数据结构
  let rootData = { ...this.navigation.graphStack[0] };
  
  // 递归重建子图数据...
  return rebuildWithSubgraphs(rootData);
}
```

### 数据一致性检查

```javascript
handleSearch(query) {
  // 在搜索前，确保导航数据是最新的
  this.navigation.updateCurrentGraphData();
  
  // 比较实际图形和导航数据的一致性
  const actualGraphNodes = this.graph.getNodes();
  const navigationNodes = this.navigation.currentGraphData.nodes || [];
  
  console.log('🔍 [NodeSearch] 数据一致性检查:', {
    actualNodesCount: actualGraphNodes.length,
    navigationNodesCount: navigationNodes.length,
    actualNodeIds: actualGraphNodes.map(n => n.get('id')),
    navigationNodeIds: navigationNodes.map(n => n.id)
  });
}
```

## 8. 调试和错误处理

### 详细调试输出

```javascript
// 搜索过程调试
console.log('🔍 [NodeSearch] 开始搜索:', query);
console.log('🔍 [NodeSearch] 找到所有节点数量:', allNodes.length);
console.log('🔍 [NodeSearch] 匹配结果数量:', this.searchResults.length);

// 导航过程调试
console.log('🔍 [NodeSearch] 导航到节点:', {
  nodeId: node.id,
  nodeLabel: node.label,
  path: path,
  nodeType: nodeInfo.nodeType || 'unknown'
});

// 居中过程调试
console.log('🔍 [NodeSearch] 选择状态验证:', {
  targetNodeId: nodeId,
  selectedItemId: selectedItem ? selectedItem.get('id') : null,
  selectionCorrect: selectedItem && selectedItem.get('id') === nodeId
});
```

### 错误处理机制

```javascript
// 节点查找失败处理
if (!node) {
  console.error('🔍 [NodeSearch] 未找到节点:', nodeId);
  console.log('🔍 [NodeSearch] 当前图中的所有节点:', this.graph.getNodes().map(n => n.get('id')));
  return;
}

// focusItem失败回退
try {
  this.graph.focusItem(node, true, { easing: 'easeCubic', duration: 200 });
} catch (error) {
  console.error('🔍 [NodeSearch] focusItem 执行失败:', error);
  this.fallbackCenterNode(node);
}

// 路径节点查找失败
if (!targetNode) {
  console.error('🔍 [NodeSearch] 未找到路径节点:', stepNodeName);
  console.log('🔍 [NodeSearch] 当前层级可用节点:', 
    currentNodes.map(n => n.getModel().label || 'Unnamed')
  );
  return;
}
```

## 9. 集成和初始化

### 模块集成

```javascript
// 在 src/index.js 中
import { NodeSearch, bindSearchEvents } from './search';

// 初始化搜索模块
const nodeSearch = new NodeSearch(graph, navigation);

// 绑定搜索事件
bindSearchEvents(graph, nodeSearch);
```

### 样式集成

```css
/* 在 src/styles/index.css 中添加搜索对话框样式 */
.search-dialog { /* ... */ }
.search-input { /* ... */ }
.search-results { /* ... */ }
.search-result-item { /* ... */ }
```

## 10. 功能特性总结

### 核心特性

- ✅ **实时搜索**: 输入时立即显示匹配结果
- ✅ **跨层级搜索**: 可以搜索任意子图中的节点
- ✅ **路径显示**: 每个结果显示完整的层级路径
- ✅ **键盘导航**: 支持上下箭头选择，回车确认
- ✅ **智能居中**: 使用G6的focusItem API，带动画效果
- ✅ **数据同步**: 确保搜索使用最新的图形数据
- ✅ **状态兼容**: 与现有选择机制完全兼容

### 快捷键支持

- **Ctrl+F**: 打开搜索对话框
- **↑/↓**: 在搜索结果中导航
- **Enter**: 选择当前结果并跳转
- **Escape**: 关闭搜索对话框

### 调试功能

- 详细的控制台调试输出
- 数据一致性检查
- 选择状态验证
- 错误处理和回退机制

## 11. 使用指南

### 基本操作

1. 按 **Ctrl+F** 打开搜索对话框
2. 输入节点名称进行搜索（支持模糊匹配）
3. 使用上下箭头选择结果
4. 按回车跳转到选中的节点
5. 按Escape关闭对话框

### 高级功能

- **跨层级搜索**: 搜索任意子图中的节点，系统会自动导航到正确位置
- **路径显示**: 每个结果显示完整路径，如 "Root / NodeA / NodeB"
- **实时更新**: 新绘制的节点立即可以搜索到
- **智能居中**: 跳转后节点会自动居中显示

### 注意事项

- 只有矩形节点支持子图功能
- 搜索基于节点标签（label）进行匹配
- 搜索不区分大小写
- 空搜索会显示所有节点

## 12. 技术亮点

### 架构设计

- **模块化设计**: 独立的搜索模块，易于维护和扩展
- **事件驱动**: 通过事件系统与其他模块通信
- **状态管理**: 统一的选择状态管理机制

### 性能优化

- **实时搜索**: 高效的字符串匹配算法
- **数据缓存**: 智能的数据更新机制
- **动画优化**: 快速的动画效果（200ms）

### 用户体验

- **VSCode风格**: 熟悉的搜索界面和交互
- **键盘友好**: 完整的键盘导航支持
- **视觉反馈**: 丰富的状态指示和动画效果

这个搜索功能为嵌套白板项目提供了强大的导航能力，让用户能够快速定位和访问任意层级的节点，大大提升了使用效率。
