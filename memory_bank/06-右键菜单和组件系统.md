# 右键菜单和组件系统

## 系统概述

右键菜单和组件系统提供了丰富的用户交互功能，包括文本编辑、样式调整、图片预览等。系统结合了原生JavaScript的菜单实现和React组件的现代化UI。

## 1. 右键菜单系统 (contextMenu/)

### ContextMenu 类 (contextMenu.js)

#### 核心结构
```javascript
class ContextMenu {
  constructor(graph) {
    this.graph = graph;
    this.menu = this.createContextMenu();
    document.body.appendChild(this.menu);
    this.bindEvents();
  }
}
```

#### 菜单结构

##### 主菜单项
1. **编辑文本** (✏️ Edit Text)
2. **字体大小** (📝 Font Size) - 带子菜单
3. **文本颜色** (🎨 Text Color) - 带子菜单

##### 字体大小子菜单
```javascript
const fontSizeSubmenu = this.createSubmenu([
  { size: 12, label: 'Small (12px)' },
  { size: 16, label: 'Medium (16px)' },
  { size: 20, label: 'Large (20px)' },
  { size: 24, label: 'Extra Large (24px)' }
]);
```

##### 文本颜色子菜单
```javascript
const colorSubmenu = this.createColorSubmenu([
  { color: colors.black, label: 'Black' },
  { color: colors.primary, label: 'Blue' },
  { color: colors.success, label: 'Green' },
  { color: colors.error, label: 'Red' },
  { color: colors.purple, label: 'Purple' },
  { color: colors.warning, label: 'Orange' }
]);
```

### 菜单创建方法

#### createContextMenu() - 创建主菜单
```javascript
createContextMenu() {
  const menu = document.createElement('div');
  menu.id = 'context-menu';
  menu.className = 'context-menu';
  menu.style.display = 'none';

  // 编辑文本选项
  const editItem = this.createMenuItem('edit', '✏️', 'Edit Text');
  menu.appendChild(editItem);

  // 字体大小选项
  const fontSizeItem = this.createMenuItem('font-size', '📝', 'Font Size');
  const fontSizeSubmenu = this.createSubmenu([...]);
  fontSizeItem.appendChild(fontSizeSubmenu);
  menu.appendChild(fontSizeItem);

  // 文本颜色选项
  const textColorItem = this.createMenuItem('text-color', '🎨', 'Text Color');
  const colorSubmenu = this.createColorSubmenu([...]);
  textColorItem.appendChild(colorSubmenu);
  menu.appendChild(textColorItem);

  return menu;
}
```

#### createMenuItem() - 创建菜单项
```javascript
createMenuItem(action, icon, label) {
  const item = document.createElement('div');
  item.className = 'menu-item';
  item.dataset.action = action;
  
  const iconSpan = document.createElement('i');
  iconSpan.className = 'menu-icon';
  iconSpan.textContent = icon;
  
  item.appendChild(iconSpan);
  item.appendChild(document.createTextNode(label));
  
  return item;
}
```

#### createColorSubmenu() - 创建颜色子菜单
```javascript
createColorSubmenu(items) {
  const submenu = document.createElement('div');
  submenu.className = 'submenu color-submenu';
  
  items.forEach(item => {
    const menuItem = document.createElement('div');
    menuItem.className = 'menu-item color-item';
    menuItem.dataset.color = item.color;
    
    const colorDot = document.createElement('span');
    colorDot.className = 'color-dot';
    colorDot.style.background = item.color;
    
    menuItem.appendChild(colorDot);
    menuItem.appendChild(document.createTextNode(item.label));
    submenu.appendChild(menuItem);
  });
  
  return submenu;
}
```

### 菜单显示和交互

#### show() - 显示菜单
```javascript
show(x, y, node) {
  this.menu.style.display = 'block';
  this.menu.style.left = `${x}px`;
  this.menu.style.top = `${y}px`;
  
  // 存储当前节点引用
  this.menu.dataset.nodeId = node.get('id');
  
  // 获取节点当前样式
  const model = node.getModel();
  const currentFontSize = model.labelCfg?.style?.fontSize || styleConfig.fontSize.medium;
  const currentColor = model.labelCfg?.style?.fill || colors.black;
  
  // 更新字体大小项显示当前大小
  this.menu.querySelectorAll('.submenu .menu-item[data-size]').forEach(item => {
    const size = parseInt(item.dataset.size);
    if (size === currentFontSize) {
      item.style.fontWeight = 'bold';
      item.style.color = colors.primary;
    } else {
      item.style.fontWeight = 'normal';
      item.style.color = colors.black;
    }
  });

  // 更新颜色项显示当前颜色
  this.menu.querySelectorAll('.color-item').forEach(item => {
    const color = item.dataset.color;
    if (color === currentColor) {
      item.classList.add('active');
    } else {
      item.classList.remove('active');
    }
  });
}
```

#### 菜单事件处理
```javascript
bindEvents() {
  // 处理菜单项点击
  this.menu.addEventListener('click', (ev) => {
    const target = ev.target.closest('.menu-item');
    if (!target) return;
    
    const nodeId = this.menu.dataset.nodeId;
    const node = this.graph.findById(nodeId);
    
    if (!node) return;
    
    if (target.dataset.action === 'edit') {
      startEditingLabel(node, this.graph);
    } else if (target.dataset.size) {
      // 更新字体大小
      const fontSize = parseInt(target.dataset.size);
      this.graph.updateItem(node, {
        labelCfg: {
          style: {
            ...node.get('labelCfg')?.style,
            fontSize
          }
        }
      });
    } else if (target.dataset.color) {
      // 更新文本颜色
      const color = target.dataset.color;
      this.graph.updateItem(node, {
        labelCfg: {
          style: {
            ...node.get('labelCfg')?.style,
            fill: color
          }
        }
      });
    }
    
    this.hide();
  });

  // 点击外部隐藏菜单
  document.addEventListener('click', (ev) => {
    if (!ev.target.closest('.context-menu')) {
      this.hide();
    }
  });

  // 按下回车键编辑
  document.addEventListener('keydown', (e) => {
    // 如果正在输入文本，不处理快捷键
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
      return;
    }
    
    const selectedItem = this.graph.get('selectedItem');
    if (e.key === 'Enter' && selectedItem && 
        selectedItem.getModel().type !== 'text-only') {
      e.preventDefault();
      startEditingLabel(selectedItem, this.graph);
    }
  });
}
```

## 2. 文本编辑器 (labelEditor.js)

### startEditingLabel 函数

#### 核心功能
- **原地编辑**: 在节点位置创建输入框
- **自动定位**: 根据节点位置和大小计算输入框位置
- **样式匹配**: 输入框样式与节点文本样式保持一致

#### 实现代码
```javascript
export const startEditingLabel = (item, graph) => {
  const model = item.getModel();
  const currentLabel = model.label || '';
  
  // 获取节点位置和大小
  const nodeBox = item.getBBox();
  const { x, y, width, height } = nodeBox;
  const point = graph.getCanvasByPoint(x, y);
  
  // 创建输入元素
  const input = document.createElement('input');
  input.value = currentLabel;
  input.className = 'node-editor';
  input.style.position = 'absolute';
  input.style.width = `${Math.max(120, width)}px`;
  input.style.padding = '4px 8px';
  input.style.border = `2px solid ${colors.primary}`;
  input.style.borderRadius = '4px';
  input.style.zIndex = '1000';
  input.style.fontSize = '16px';
  input.style.backgroundColor = 'white';
  input.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
  
  // 将输入框定位到节点中心
  input.style.left = `${point.x - width/2}px`;
  input.style.top = `${point.y - height/2}px`;
  
  document.body.appendChild(input);
  input.focus();
  input.select(); // 选中所有文本以便编辑

  // 处理输入提交
  const handleSubmit = () => {
    const newLabel = input.value.trim();
    if (newLabel) {
      graph.updateItem(item, { label: newLabel });
    }
    document.body.removeChild(input);
  };

  // 处理输入事件
  textarea.addEventListener('blur', handleSubmit);
  textarea.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      // Enter键完成编辑
      e.preventDefault();
      handleSubmit();
    } else if (e.key === 'Enter' && e.shiftKey) {
      // Shift+Enter换行，阻止事件冒泡到document级别
      e.stopPropagation();
    } else if (e.key === 'Escape') {
      // Escape 取消
      e.preventDefault();
      handleCancel();
    }
  });
};
```

#### 特性说明
- **自动聚焦**: 创建后立即获得焦点
- **全选文本**: 方便用户直接输入替换
- **智能尺寸**: 输入框宽度至少120px，或节点宽度
- **多行支持**: 使用textarea支持多行文本编辑
- **自动调整高度**: 根据内容自动调整输入框高度
- **键盘事件处理**: 
  - Enter键：完成编辑并保存
  - Shift+Enter键：换行
  - Escape键：取消编辑
  - 失焦：自动保存
- **事件冒泡控制**: 防止编辑器内按键触发全局快捷键

## 3. React组件系统 (components/)

### ImagePreview 组件 (ImagePreview.jsx)

#### 组件功能
- **全屏预览**: 覆盖整个视口的图片预览
- **缩放功能**: 鼠标滚轮缩放 (0.1x - 5x)
- **拖拽移动**: 拖拽图片在预览区域内移动
- **背景关闭**: 点击背景区域关闭预览
- **状态显示**: 显示当前缩放百分比

#### 核心状态
```javascript
const ImagePreviewComponent = ({ src, onClose }) => {
  const [scale, setScale] = useState(1);           // 缩放比例
  const [position, setPosition] = useState({ x: 0, y: 0 }); // 图片位置
  const isDragging = useRef(false);                // 拖拽状态
  const startPos = useRef({ x: 0, y: 0 });        // 拖拽起始位置
  const containerRef = useRef(null);               // 容器引用
};
```

#### 缩放功能实现
```javascript
const handleWheel = (e) => {
  e.preventDefault();
  const delta = e.deltaY > 0 ? -0.1 : 0.1;
  setScale(prevScale => {
    const newScale = Math.min(Math.max(prevScale + delta, 0.1), 5);
    return newScale;
  });
};
```

#### 拖拽功能实现
```javascript
const handleMouseDown = (e) => {
  if (e.target === containerRef.current) return;
  e.preventDefault();
  isDragging.current = true;
  startPos.current = { x: e.clientX - position.x, y: e.clientY - position.y };
  e.target.style.cursor = 'grabbing';
};

const handleMouseMove = (e) => {
  if (!isDragging.current) return;
  e.preventDefault();
  const newX = e.clientX - startPos.current.x;
  const newY = e.clientY - startPos.current.y;
  setPosition({ x: newX, y: newY });
};
```

#### 组件渲染
```javascript
return (
  <div
    ref={containerRef}
    style={{
      position: 'fixed',
      top: 0,
      left: 0,
      width: '100vw',
      height: '100vh',
      backgroundColor: 'rgba(0, 0, 0, 0.85)',
      zIndex: 1000,
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
    }}
    onClick={handleBackgroundClick}
    onWheel={handleWheel}
    onMouseMove={handleMouseMove}
    onMouseUp={handleMouseUp}
  >
    {/* 关闭按钮 */}
    <div style={{...}} onClick={onClose}>×</div>

    {/* 缩放信息 */}
    <div style={{...}}>{Math.round(scale * 100)}%</div>

    <Image
      src={src}
      preview={false}
      style={{
        transform: `scale(${scale}) translate(${position.x / scale}px, ${position.y / scale}px)`,
        cursor: isDragging.current ? 'grabbing' : 'grab',
        maxWidth: '90vw',
        maxHeight: '90vh',
        objectFit: 'contain',
      }}
      onMouseDown={handleMouseDown}
      draggable={false}
    />
  </div>
);
```

#### 生命周期管理
```javascript
// 在组件挂载时禁用滚动，卸载时恢复
React.useEffect(() => {
  const originalStyle = window.getComputedStyle(document.body).overflow;
  document.body.style.overflow = 'hidden';
  
  return () => {
    document.body.style.overflow = originalStyle;
  };
}, []);
```

### showImagePreview 函数

#### 动态挂载组件
```javascript
export const showImagePreview = (imgSrc) => {
  const container = document.createElement('div');
  document.body.appendChild(container);

  const root = createRoot(container);
  const handleClose = () => {
    root.unmount();
    document.body.removeChild(container);
  };

  root.render(
    <ImagePreviewComponent
      src={imgSrc}
      onClose={handleClose}
    />
  );
};
```

## 4. 样式系统

### 右键菜单样式
```css
.context-menu {
  position: fixed;
  background: white;
  border: 1px solid #e8e8e8;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  padding: 6px 0;
  min-width: 200px;
  z-index: 1000;
}

.menu-item {
  padding: 10px 20px;
  cursor: pointer;
  display: flex;
  align-items: center;
  position: relative;
  color: #333;
  font-size: 18px;
  transition: all 0.3s;
}

.menu-item:hover {
  background: #e6f7ff;
  color: #1890ff;
}
```

### 子菜单样式
```css
.submenu {
  display: none;
  position: absolute;
  left: 100%;
  top: 0;
  background: white;
  border: 1px solid #e8e8e8;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  min-width: 180px;
  margin-left: 2px;
}

.menu-item[data-action="font-size"]:hover .submenu,
.menu-item[data-action="text-color"]:hover .submenu {
  display: block;
}
```

### 颜色选择器样式
```css
.color-dot {
  display: inline-block;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  margin-right: 12px;
  border: 1px solid rgba(0,0,0,0.1);
  vertical-align: middle;
}

.color-item.active {
  font-weight: bold;
  color: #1890ff;
}

.color-item.active .color-dot {
  border: 2px solid #1890ff;
}
```

### 文本编辑器样式
```css
.node-editor {
  font-family: Arial, sans-serif;
  font-size: 20px;
  background: white;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  outline: none;
  padding: 8px 12px;
  border: 2px solid #1890ff;
  border-radius: 4px;
}

.node-editor:focus {
  border-color: #40a9ff;
  box-shadow: 0 0 0 2px rgba(24,144,255,0.2);
}
```

## 5. 键盘事件处理优化

### 问题背景
在原始实现中，当用户在文本编辑器中按下Enter键时，会同时触发两个事件：
1. 编辑器内的Enter键处理（用于换行）
2. 全局的Enter键监听器（用于开始新的编辑）

这导致用户在编辑器中按Enter键换行时，会意外地重新开始编辑会话。

### 解决方案

#### 1. 编辑器内事件冒泡控制
```javascript
textarea.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    // Enter键完成编辑
    e.preventDefault();
    handleSubmit();
  } else if (e.key === 'Enter' && e.shiftKey) {
    // Shift+Enter换行，阻止事件冒泡到document级别
    e.stopPropagation();
  } else if (e.key === 'Escape') {
    // Escape 取消
    e.preventDefault();
    handleCancel();
  }
});
```

#### 2. 全局事件监听器优化
```javascript
document.addEventListener('keydown', (e) => {
  // 如果正在输入文本，不处理快捷键
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
    return;
  }
  
  const selectedItem = this.graph.get('selectedItem');
  if (e.key === 'Enter' && selectedItem && 
      selectedItem.getModel().type !== 'text-only') {
    e.preventDefault();
    startEditingLabel(selectedItem, this.graph);
  }
});
```

### 优化后的键盘行为

#### 全局快捷键（选中节点时）
- **Enter键**: 开始编辑选中的矩形节点
- **Escape键**: 取消当前工具模式
- **空格键**: 自动适配视图

#### 编辑器内快捷键
- **Enter键**: 完成编辑并保存
- **Shift+Enter键**: 换行（不完成编辑）
- **Escape键**: 取消编辑
- **失焦**: 完成编辑并保存

### 技术要点

1. **事件冒泡控制**: 使用 `e.stopPropagation()` 防止编辑器内事件冒泡到document级别
2. **输入状态检测**: 在全局监听器中检查当前焦点元素，避免在编辑时触发快捷键
3. **事件优先级**: 编辑器内事件处理优先于全局事件处理
4. **用户体验**: 符合常见文本编辑器的键盘习惯

## 6. 交互流程

### 右键菜单使用流程
1. 用户右键点击节点
2. 触发 `node:contextmenu` 事件
3. ContextMenu.show() 显示菜单
4. 根据节点当前样式更新菜单状态
5. 用户点击菜单项
6. 执行相应操作（编辑文本、修改样式）
7. 隐藏菜单

### 文本编辑流程
1. 触发编辑（右键菜单、双击文本节点、Enter键）
2. startEditingLabel() 创建输入框
3. 输入框定位到节点位置
4. 用户输入文本
5. 确认输入（Enter、失焦）
6. 更新节点标签
7. 移除输入框

### 图片预览流程
1. 用户双击图片节点
2. 触发 showImagePreview()
3. 动态创建React组件
4. 全屏显示图片预览
5. 用户交互（缩放、拖拽）
6. 关闭预览（点击背景、关闭按钮）
7. 卸载组件并清理DOM


